#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

# Copyright 2004, 2005 University of Oslo, Norway
#
# This file is part of Cerebrum.
#
# Cerebrum is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Cerebrum is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cerebrum; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

import ConfigParser
import os
import sys
import logging, logging.config
import errno
import types
import optparse

def syslog_to_unixsocket(sysloghandler):
    '''Converts a SysLogHandler('localhost', 514) to SysLogHandler("/dev/log") if supported.
    Ugly as ***, but works.

    Raises "error: (95, 'Socket operation on non-socket')" if logging to /dev/log is unsupported
    '''
    
    import socket
    myaddress = "/dev/log"

    # syslog may require either DGRAM or STREAM sockets
    try:
        mysocket = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
        mysocket.connect(myaddress)
    except socket.error:
        mysocket.close()
        mysocket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        mysocket.connect(myaddress)

    sysloghandler.unixsocket = 1
    sysloghandler.address = myaddress
    sysloghandler.socket = mysocket

_conf = ConfigParser.SafeConfigParser()
confpath= os.environ.get("CERECONF_DIR", "@CONFDIR@")+'/'
_conf.read((confpath+'sync.conf.template', confpath+'sync.conf'))

logging_ini= "@CONFDIR@"+"/logging.ini"   
if _conf.has_option('logging','ini_path'):
    logging_ini= _conf.get('logging','ini_path')
logging.config.fileConfig(logging_ini)
loggername= 'ceresync'       
if _conf.has_option('logging','logger'):
    loggername= _conf.get('logging','logger')
                         
logger= logging.getLogger(loggername)
logger.name= os.path.basename(sys.argv[0])

# Convert any SysLogHandler('localhost', 514) to SysLogHandler("/dev/log") if
# possible. This increases the chance of successful syslogging on linux.
try:
    for h in logger.handlers:
        # Ugh, there must be a better way than this...
        if h.__class__.__name__ == 'SysLogHandler':
            if type(h.address) == types.TupleType and h.address[0] == 'localhost' and h.address[1] == 514:
                syslog_to_unixsocket(h)
except Exception, e:
    pass # This normally fails on solaris, where unix sockets are not supported

def read(files, strict=False, **kwargs):
    """Read an array of configuration files
    """

    logger.debug("reading config file(s) %s", files)
    if type(files) == types.StringType:
        files = [ files ]
    if strict:
        for f in files:
            if not os.path.isfile(f):
                raise IOError(errno.ENOENT, "No such file or directory: %s" % f)
            if not os.access(f, os.R_OK):
                raise IOError(errno.EACCES, "Access denied: %s" % f)
    return _conf.read(files, **kwargs)

# Return list of all optins in a section. Inherits doc from _conf.options()
def options(section):
    return _conf.options(section)
options.__doc__ = _conf.options.__doc__

def get(section, option, default=None, **kwargs):
    """get the option from a section in the config, or use default if set"""
    if _conf.has_option(section, option) and default is not None:
        return default
    return _conf.get(section, option, **kwargs)

def getboolean(section, option, default=None, allow_none=False, **kwargs):
    """get the option from a section in the config, or use default if set.
    Setting allow_none will make "None" a valid return value"""

    if _conf.has_option(section, option) and default is not None:
        return default
    if allow_none and _conf.get(section, option, **kwargs) == "None":
        return None
    return _conf.getboolean(section, option, **kwargs)

def apply_quarantine(obj, typestr):
    """
    Apply rules set in the [OBJTYPE_quarantenes] section of the config
    file. For each quarantene the user may override one atttribute.
    If no rule exists for a given quarantene, the DEFAULT rule will be used.
    The format is:
    [account_quarantenes]
    nologin: shell="/bin/nologin"
    DEFAULT: passwd="*"
    """
    for q in obj.quarantines:
        try:
            a=_conf.get('%s_quarantenes' % typestr, q)
        except ConfigParser.NoOptionError:
            try:
                a=_conf.get('%s_quarantenes' % typestr, "DEFAULT")
            except ConfigParser.NoOptionError:
                return
        try:
            (var, val) = a.split('=')
            val=eval(val)  # ouch! but needed for strings/ints/etc
        except ValueError:
            logger.error("Bad quarantene action \"%s\"" % a)
        logger.debug("%s has quarantine %s. Setting %s= %s", obj.name, 
                     q, var, val)
        setattr(obj, var, val)

def apply_override(obj, typestr):
    """
    Apply rules set in the [OBJTYPE_override] section of the config file.
    These values will override any values supplied by the server.
    The format is:
    [account_override]
    homedir: /home/%(name)s
    """
    section='%s_override' % typestr
    attribs = dict([(x,y) for x, y in obj.__dict__.items()
                    if y not in ('', -1)])
    if _conf.has_section(section):
        for a in _conf.options(section):
            if attribs.has_key(a): del attribs[a]
        for a in _conf.options(section):
            setattr(obj, a, _conf.get(section, a, vars=attribs))

def apply_default(obj, typestr):
    """
    Apply rules set in the [OBJTYPE_default] section of the config file.
    These values will be used if no value is supplied by the server.
    The format is:
    [account_default]
    homedir: /home/%(name)s
    """
    section='%s_default' % typestr
    attribs = dict([(x,y) for x, y in obj.__dict__.items()
                    if y not in ('', -1)])
    if _conf.has_section(section):
        for a in _conf.options(section):
            # "" or -1 for nonexisting values is an spine-ism
            if (not obj.__dict__.has_key(a)) or getattr(obj, a) == "" or getattr(obj, a) == -1:
                setattr(obj, a, _conf.get(section, a, vars=attribs))

def _toggle_once(parser, dest, value, options):
    """Toggle the option dest to the boolean value, and fail if it has already been set.
    Used by make_bulk_options()"""

    old_value = getattr(parser.values, dest)
    if old_value is not None and old_value is not value:
        raise optparse.OptionValueError("Only one of %s options should be provided" % options)
    setattr(parser.values, dest, value)

def make_bulk_options():
    """Return a list of bulk-related boolean options, for use in make_option()

    Only one option affecting incremental will be allowed, the others may be
    specified multiple times and the last one specified will count.

      Affected config value | Enabling options  | Disabling options | Default
      ----------------------+-------------------+-------------------+--------
      args, incremental     | -i, --incremental | -b, --bulk        | None
      args, add             | -a, --add         | --no-add          | False
      args, update          | -u, --update      | --no-update       | False
      args, delete          | -d, --delete      | --no-delete       | True

    """

    return [
        make_option("-i", "--incremental", action="callback", dest="incremental", default=None,
                     callback=lambda o,lo,v,p: _toggle_once(p, "incremental", True, "--bulk or --incremental"),
                     help="incremental synchronization. " \
                         +"The --add, --update and --delete arguments are ignored"),
        make_option("-b", "--bulk", action="callback",
                     callback=lambda o,lo,v,p: _toggle_once(p, "incremental", False, "--bulk or --incremental"),
                     help="bulk synchronization"),
    
        make_option("-a", "--add", action="store_true", default=False,
                     help="add accounts"),
        make_option("-u", "--update", action="store_true", default=False,
                     help="update accounts"),
        make_option("-d", "--delete", action="store_true", default=True,
                            help="delete accounts (default)"),
    
        # These "--no"-options modify the same value as their counterparts
        # above, and use the default value defined there.
        make_option("--no-add", action="store_false", dest="add",
                     help="do not add accounts (default)"),
        make_option("--no-update", action="store_false", dest="update",
                     help="do not update accounts (default)"),
        make_option("--no-delete", action="store_false", dest="delete",
                            help="do not delete accounts"),
    ]


# Creates an option for parse_args, inherits doc from optparse
def make_option(*opts, **attrs):
    return optparse.make_option(*opts, **attrs)
make_option.__doc__ = optparse.make_option.__doc__

def _increase_verbosity(opt, lopt, file, parser):
    parser.values.verbose = True
    # Search for a loghandler printing to stderr, and increase the verbosity level
    for h in logger.handlers:
        # Only change stderr
        if h.__class__.__name__ == 'StreamHandler' and h.stream.fileno() == 2:
            h.setLevel(max(0, h.level-10))

def parse_args(options=[]):
    """parse command-line arguments.
    
    options is a list of option arguments, created with make_option()
    
    Default options are:
     -h, --help                  Show help message and exit
     -v, --verbose               Be verbose
     -c CONFIG, --config=CONFIG  Read config from CONFIG
 
    Retrieve your parsed args using get('args', <longoption>), 
    without the '--' in front of the longoption.

    example: get('args', 'verbose')
    """

    parser = optparse.OptionParser()
    parser.add_option("-v", "--verbose", help="be verbose", dest="verbose", default=False, 
                      action="callback", callback=_increase_verbosity)
    parser.add_option("-c", "--config", help="read config from CONFIG", 
                      action="callback", type="string", 
                      callback=lambda opt, lopt, file, p: read(file, strict=True))
    for option in options:
        parser.add_option(option)
    (options, args) = parser.parse_args()

    # Add all args to the "args" section in _conf, so get('args', 'option') will work
    if not _conf.has_section('args'):
        _conf.add_section('args')

    for k in dir(options):
        v = getattr(options, k)
        # Ignore private vars and methods
        # NB: type(parser.add_option) is <type 'instancemethod'>
        if k[0] == "_" or type(v) == type(parser.add_option):
            continue
        _conf.set('args', k, str(v))

    return args
