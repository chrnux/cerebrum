Quick howto on the layout of a ceresync backend
===============================================

Ceresync concist of different types of backends.

A backend can be ldap,file,etc.

For each backend, you can store information for different types of
entity types, like Person, Account, Group.

It is unclear if it's the backend's responsibility to ignore or report
unsupported entity types.  For instance, for Accounts, backends should
silently ignore those that lack posix stuff if the backend require posix
material.  

For file-type backend, this can be almost mapped to::
    /etc/passwd
    /etc/shadow
    /etc/group
    /etc/aliases

Each backend implements a set of functions:
    begin(incr=False) # Defaults to work in bulk-mode
    close() # Close open connections
    abort() # Stop ongoing operations
    add(obj)
    update(obj)
    delete(obj)

obj.name is always the primary key in the database (e.g. username)

obj has other attributes as well, and each backend will always
receive the full object (possibly exception for delete).

Typical bulk-synchronization:
    begin()
    add(obj)
    close() # will also remove any unwanted objects

add in incr=False -mode is supposed to work as if the object doesn't exist,
and shouldn't give an error-message.

Starting a bulk synchronization means that all objects will be
transfered. The backend should either delete or compare all existing
objects on his end. (ie. start with a blank file)


Typical incremental run:
    begin(incr=True)
    add(a)
    update(b)
    delete(c)
    add(d)
    delete(e)
    close() 

Incremental runs will "modify" the backend's database since only new,
changed or deleted objects are passed on. This means that the backend
should not delete existing objects unless delete() is called. For a file
based backend, this means that the file should be edited "in place" in
some way.    

add and update in incr=True -mode is supposed to work if object exist
in backend or not, but "should" give a warning if object doesn't exist
when calling update() or delete(), or if it exist when calling add().

If an error gets raised, it's expected that abort() is called.

abort() doesn't need to rollback changes done since begin() - 
but each backend need to document what will happen. The preferred
behaviour is that no changes is submitted to the backend database unless
close() is called, and that an abort() avoids committing such changes. 


Windows sync client installation
--------------------------------

There are several dependencies that must be installed before running the
Sync client.

Python with win32 extensions 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

From www.python.org, download and install Python 2.3 for Windows by
running the .exe file.

From http://starship.python.net/crew/mhammond/win32/Downloads.html 
download the win32all extensions for your selected Python version and
install by running .exe.  This will enable binding to COM objects and
thereby Active Directory.


omniORB (Corba library)
~~~~~~~~~~~~~~~~~~~~~~~

From http://omniorb.sourceforge.net/download.html download the binary
versions of omniORB and omniORBpy, for instance:
  omniORB-4.0.5-win32-vc6.zip
  omniORBpy-2.5-win32-python2.3.zip

omniORB is used to connect to the Spine Corba interface and convert the
IDL specifications received to generated Python modules.

Note that both win32 extensions and omniORBpy binaries must match the
main Python version, ie 2.3 in these examples. 

Unpack omniORB and omniORBpy to c:\temp or something, and copy the
content of each folder to a new directory c:\omniORB. In c:\omniORB you
should have the directories bin, lib, etc, containing binaries from both
packages.

OpenSSL
~~~~~~~

From http://www.openssl.org/related/binaries.html download OpenSSL
binaries for Windows. Currently, omniORB seems to be linked to OpenSSL
v.0.9.6 and not 0.9.7, so download OpenSSL v0.9.6m or whatever latest
0.9.6 release.

The OpenSSL installation will install several files to C:\openssl which
you really don't need, the one you do need is these DLLs that are
installed into c:\windows\system32::

  libeay32.dll
  ssleay32.dll
  libssl32.dll

GnuPG
-----

PGP is used to encrypt cleartext passwords in the database, as Ceresync
needs the cleartext password to set it in Active Directory. (However, AD
does not store the password in cleartext, but there is no official way
to store the 'hash' directly)

Download GnuPG for Win32 from
http://www.gnupg.org/(en)/download/index.html - for instance
gnupg-w32cli-1.4.0a.zip. Extract to c:\gnupg

Download libiconv.dll from http://prdownloads.sourceforge.net/gettext/ -
for instance libiconv-1.9.1.bin.woe32.zip. Extract bin\libiconv.dll to
c:\gnupg or c:\windows\system32

Start a Command shell (start->run->cmd ) and run these commands:

  c:
  cd \gnupg
  gpg --genkey

Use the defaults. Generate a key, name it "Cerebrum win.ntnu.no"
(the AD domain name) or something. Use a blank password.

The output will be something like:

    pub   1024D/E068C28A 2005-03-12 [expires: 2006-03-12]
          Key fingerprint = D29C 4171 A980 DE4C 789F  CFB4 E312 D5A7 E068 C28A
    uid                  Cerebrum twin.itea.ntnu.no
    sub   2048g/4D791EAD 2005-03-12 [expires: 2006-03-12] 

E068C28A is the key ID to be inserted into cereconf.py AUTH_PGP. You
will also have to extract the generated public key and import it on the
Spine server:

  gpg --armor --export 0xE068C28A > twin.itea.ntnu.no.asc

(You might also use the famous cut-and-paste technology =) )

On the Cerebrum server:

  gpg --import twin.itea.ntnu.no.asc
  gpg --edit-key 0xE068C28A
     Sign the key so that gpg won't complain about "untrusted key".


Environment settings
~~~~~~~~~~~~~~~~~~~~

Sadly enough, several environment settings must be set.

Go to Control panel -> System -> Advanced -> Environment Variables  
We will modify the System variables, as they are global to all users on
the server.

Modify PATH and add::

  ;c:\python23;c:\omniORB\bin\x86_win32

This will make sure both Python and onniORB binaries and libraries like
omniidl are available. Note that in Windows, PATH is used even to search
for DLLs.

Add a new System variable named PYTHONPATH and set it to::
  
  c:\omniORB\lib\python;c:\omniorb\lib\x86_win32

This will make sure that Python will locate omniORB modules.


Check the installation
~~~~~~~~~~~~~~~~~~~~~~

System environments are effective for any new programs started. 
Do Start->Run and start cmd (the command prompt)

Run python. The Python prompt ">>> " should appear. Try::

    >>> from omniORB import CORBA
    >>>

This means that omniORB was installed correctly. Type Ctrl-Z and Enter
to exit.

Check if omniidl (the IDL -> Python converter) is available and works.
You don't need a IDL file to test this, we'll just check that the
backend for Python generation is available. Run:

    C:\> omniidl -b python fisk.idl
    omniidlk: 'fisk.idl' does not exist

This is the expected error message. If the omniORBpy package was not
installed, you would instead get an error message like:

    C:\> omniidl -b python fisk.idl
    omniidl: Could not import back-end 'python'
    omniidl: Maybe you need to use the -p option?
    omniidl: (The error was 'No module named python')
    
If you get this, make sure you copy the "bin" and "lib" libraries from
omniORBpy package top c:\omniORB, and that your omniORBpy package
matches the Python version. Also see omniORBpy README.txt for which
version of omniORB is required.  In our example, omniORBpy 2.5 requires    
omniORB 4.0.x.

Now all Spine sync client dependencies should be installed. Edit 
the paths in client.conf and sync.conf so that they are Windows
compatible, ie.  cache_dir: c:\temp instead of /tmp

Run python sync.py to run the server connection tests.
