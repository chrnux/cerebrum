#!/usr/bin/env python2.2
# -*- coding: iso-8859-1 -*-

# Copyright 2003 University of Oslo, Norway
#
# This file is part of Cerebrum.
#
# Cerebrum is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Cerebrum is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cerebrum; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

import getopt
import sys
import os
import re

import xml.sax

import cerebrum_path
import cereconf
from Cerebrum import Errors
from Cerebrum import Person
from Cerebrum.Utils import Factory
from Cerebrum.modules import Email
from Cerebrum.modules import PosixUser
from Cerebrum.modules.no import fodselsnr

def process_line(infile):
    f = file(infile, 'r')

    # Iterate over all persons:
    l = f.readline().strip()
    i = 1
    while l:
        if verbose > 1:
            print "Processing line: %s" % l
        fld = l.split(':')
        if len(fld) <> 4:
            sys.stderr.write("Bad line: %s. Skipping\n" % l)
            continue
        fnr, uname, type, addr = fld
        if not fnr == "":
            if verbose > 1:
                print "Processing person: %s" % fnr
            p = process_person(fnr)
            if p:
                if verbose > 1:
                    print "Processing user(w. person): %s" % uname
                a = process_user(p, uname)
            else:
                sys.stderr.write("Bad fnr: %s Skipping\n" % l)
                continue
        else:
            if verbose > 1:
                print "Processing user(wo. person): %s" % uname
            a = process_user(None, uname)
        if a:
            if verbose > 1:
                print "Processing mail: %s %s" % (type, addr)
            process_mail(a, type, addr)
        else:
            sys.stderr.write("Bad uname: %s Skipping\n" % l)
        l = f.readline().strip()
        # Commit every 1000 lines.
        if i % 1000:
            db.commit()
        i = i + 1

def process_person(fnr):
    if not fodselsnr.personnr_ok(fnr):
        if verbose > 0:
            "Person exsists: %s" % fnr
        return None
    if fnr2person_id.has_key(fnr):
        return fnr2person_id[fnr]
    new_person = Person.Person(db)
    gender = co.gender_male
    if fodselsnr.er_kvinne(fnr):
        gender = co.gender_female
    year, mon, day = fodselsnr.fodt_dato(fnr)
    new_person.populate(db.Date(year, mon, day), gender)
    new_person.affect_external_id(co.system_migrate,
                                  co.externalid_fodselsnr)
    new_person.populate_external_id(co.system_migrate,
                                    co.externalid_fodselsnr,
                                    fnr)
    new_person.write_db()
    if verbose > 0:
        print "Person created: %s" % fnr
    #db.commit()
    e_id = new_person.entity_id
    new_person.clear()
    fnr2person_id[fnr] = e_id
    return e_id
    
def process_user(owner_id, uname):
    if uname == "":
        return None
    owner_type = co.entity_person
    np_type = None
    if owner_id == None:
        owner_type = co.entity_group
        owner_id = default_group_id
        np_type = int(co.account_program)
    try:
        ac.find_by_name(uname)
        if verbose > 0:
            print "User found: %s" % uname
    except Errors.NotFoundError:
        ac.populate(uname,
                    owner_type,
                    owner_id,
                    np_type,
                    default_creator_id,
                    None)
        ac.write_db()
        #db.commit()
        if verbose > 0:
            print "User created: %s" % uname
    a_id = ac.entity_id
    ac.clear()
    return a_id

def process_mail(acc_id, type, addr):
    et = Email.EmailTarget(db)
    ea = Email.EmailAddress(db)
    edom = Email.EmailDomain(db)
    epat = Email.EmailPrimaryAddressTarget(db)

    fld = addr.split('@')
    if len(fld) <> 2:
        sys.stderr.write("Bad address: %s. Skipping\n" % addr)
        return None
    lp, dom = fld
    try:
        edom.find_by_domain(dom)
        if verbose > 0:
            print "Domain found: %s: %d" % (dom, edom.email_domain_id)
    except Errors.NotFoundError:
        edom.populate(dom, "Generated by import_uname_mail.")
        edom.write_db()
        #db.commit()
        if verbose > 0:
            print "Domain created: %s: %d" % (dom, edom.email_domain_id)        
    try:
        et.find_by_entity(int(acc_id))
        if verbose > 0:
            print "EmailTarget found(account): %s: %d" % (acc_id, et.email_target_id)  
    except Errors.NotFoundError:
        et.populate(co.email_target_account, entity_id=int(acc_id),
                    entity_type=co.entity_account)
        et.write_db()
        #db.commit()
        if verbose > 0:
            print "EmailTarget created: %s: %d" % (acc_id, et.email_target_id) 
    try:
        ea.find_by_address(addr)
        if verbose > 0:
            print "EmailAddress found: %s: %d" % (addr, ea.email_addr_id) 
    except Errors.NotFoundError:
        ea.populate(lp, edom.email_domain_id, et.email_target_id)
        ea.write_db()
        #db.commit()
        if verbose > 0:
            print "EmailAddress created: %s: %d" % (addr, ea.email_addr_id) 
    if type == "defaultmail":
        try:
            epat.find(et.email_target_id)
            if verbose > 0:
                print "EmailPrimary found: %s: %d" % (addr, epat.email_target_id)
        except Errors.NotFoundError:
            if ea.email_addr_target_id == et.email_target_id:
                epat.clear()
                epat.populate(ea.email_addr_id, parent=et)
                epat.write_db()
                #db.commit()
                if verbose > 0:
                    print "EmailPrimary created: %s: %d" % (addr, epat.email_target_id)
            else:
                sys.stderr.write("EmailTarget mismatch: ea: %d, et: %d\n" % ( 
                    ea.email_addr_target_id, et.email_target_id))
    et.clear()
    ea.clear()
    edom.clear()
    epat.clear()
        
def usage():
    print """Usage: import_uname_mail.py
    -v, --verbose : Show extra information. Multiple -v's are allowed
                    (more info).
    -f, --file    : File to parse.
    """


def main():
    global verbose, db, co, ac, person, fnr2person_id
    global default_creator_id, default_group_id
    
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'vf:', ['verbose','file'])
    except getopt.GetoptError:
        usage()

    verbose = 0

    for opt, val in opts:
        if opt in ('-v', '--verbose'):
            verbose += 1
        elif opt in ('-f', '--file'):
            infile = val

    if infile is None:
        usage()

    db = Factory.get('Database')()
    db.cl_init(change_program='import_uname_mail')
    co = Factory.get('Constants')(db)
    ac = Factory.get('Account')(db)
    gr = Factory.get('Group')(db)
    person = Person.Person(db)

    fnr2person_id = {}

    for p in person.list_external_ids(id_type=co.externalid_fodselsnr):
        fnr2person_id[p['external_id']] = p['person_id']

    ac.find_by_name(cereconf.INITIAL_ACCOUNTNAME)
    default_creator_id = ac.entity_id
    gr.find_by_name(cereconf.INITIAL_GROUPNAME)
    default_group_id = gr.entity_id
    ac.clear()
    gr.clear()
    process_line(infile)
    db.commit()

if __name__ == '__main__':
    main()
