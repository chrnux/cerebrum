#!/usr/bin/env python2.2

import os
import re
import sys
import time
import getopt
import cereconf

from Cerebrum import Utils
from Cerebrum.Utils import Factory
from Cerebrum.modules.dns import ARecord
from Cerebrum.modules.dns import HostInfo
from Cerebrum.modules.dns import DnsOwner
from Cerebrum.modules.dns import IPNumber
from Cerebrum.modules.dns import CNameRecord

db = Factory.get('Database')()
co = Factory.get('Constants')(db)
#sys.argv.extend(["--logger-level", "DEBUG"])
logger = Factory.get_logger("cronjob")

header_splitter = '; WARNING: This file is autogenerated by buildzone.py\n'
default_mx = [{'pri': 10, 'ttl': None, 'target_name': 'smtp'},
              {'pri': 33, 'ttl': None, 'target_name': 'ulrik'}]
zone_postfix = '.uio.no.'

hinfo_cache = {}
def get_hinfo(code):
    code = int(code)
    if not hinfo_cache.has_key(code):
        tmp = co.HinfoCode(code)
        tmp = "%s\t%s" % (tmp.cpu, tmp.os)
        hinfo_cache[code] = tmp
    return hinfo_cache[code] 

def exp_name(name, no_dot=False):
    ret = name
    if not name[-1] == '.':
        ret = name+zone_postfix
    if no_dot and ret[-1] == '.':
        ret = ret[:-1]
    return ret

# Currently we first read all required data into memory before writing
# the new zone file.  It is assumed that it will be faster, since
# fewver sql queries will be needed.

def get_zone_data():
    # ARecord has key=a_record_id
    # HostInfo, SrvRecord has key=dns_owner_id
    # CnameRecords key=target_owner_id
    # entity2txt, entity2note has_key=entity_id
    a_records = {}
    for row in ARecord.ARecord(db).list_ext():
        a_records[int(row['a_record_id'])] = row

    hosts = {}
    pri_arecord2host = {}
    for row in HostInfo.HostInfo(db).list():
        # Unique constraint on dns_owner_id
        hosts[int(row['dns_owner_id'])] = row

    cnames = {}
    for row in CNameRecord.CNameRecord(db).list_ext():
        # TBD:  skal vi ha unique constraint på dns_owner?
        cnames.setdefault(int(row['target_owner_id']), []).append(row)
        
    # From mix-in classes
    mx_sets = {}
    for row in DnsOwner.MXSet(db).list_mx_sets():
        mx_sets.setdefault(int(row['mx_set_id']), []
                           ).append(row)

    owner_id2mx_set = {}
    for row in DnsOwner.DnsOwner(db).list():
        owner_id2mx_set[int(row['dns_owner_id'])] = int(row['mx_set_id'] or 0)

    dnsowner2txt_record = {}
    for row in DnsOwner.DnsOwner(db).list_ttl_records(field_type=co.field_type_txt):
        dnsowner2txt_record[int(row['dns_owner_id'])] = row

    srv_records = {}
    for row in DnsOwner.DnsOwner(db).list_srv_records():
        # We want them listed in the same place
        # TODO: while doing that, we want it below the first target_owner_id
        srv_records.setdefault(int(row['service_owner_id']), []).append(row) 

    return (a_records, hosts, cnames, mx_sets, owner_id2mx_set,
            dnsowner2txt_record, srv_records)

def generate_zone_file(fname, heads):
    f = Utils.SimilarSizeWriter(fname+".status", "w")
    f.set_size_change_limit(10)

    (a_records, hosts, cnames, mx_sets, owner_id2mx_set,
     dnsowner2txt_record, srv_records) = get_zone_data()
    order = a_records.keys()
    order.sort(lambda x,y: int(a_records[x]['ipnr'] - a_records[y]['ipnr']))

    # If multiple A-records have the same name with different IP, the
    # dns_owner data is only shown for the first IP.
    shown_owner = {}
    prev_name = None
    for a_id in order:
        logger.debug2("A: %s" % a_id)
        line = ''
        a_ref = a_records[a_id]
        name = a_ref['name']
        if name == prev_name:
            tmp_name = ''
        else:
            tmp_name = name
            prev_name = name
        line = "%s\t%s\tA\t%s\n" % (
            tmp_name, a_ref['ttl'] or '', a_ref['a_ip'])

        dns_owner_id = int(a_ref['dns_owner_id'])
        if shown_owner.has_key(dns_owner_id):
            f.write(line)
            continue
        shown_owner[dns_owner_id] = True
        logger.debug2("A: %s, owner=%s" % (a_id, dns_owner_id))
        if hosts.has_key(dns_owner_id):
            line += "\t%s\tHINFO\t%s\n" % (
                hosts[dns_owner_id]['ttl'] or '',
                get_hinfo(hosts[dns_owner_id]['hinfo']))
        #logger.debug("own=%i %s" % (dns_owner_id, str(owner_id2mx_set[dns_owner_id])))
        if owner_id2mx_set[dns_owner_id]:
            for mx_info in mx_sets[owner_id2mx_set[dns_owner_id]]:
                line += "\t%s\tMX\t%s\t%s\n" % (
                    mx_info['ttl'] or '', mx_info['pri'],
                    exp_name(mx_info['target_name']))
        txt = dnsowner2txt_record.get(dns_owner_id, None)
        if txt:
            line += "\t%s\tTXT\t\"%s\"\n" % (txt['ttl'] or '', txt['data'])

        for c_ref in cnames.get(dns_owner_id, []):
            line += "%s\t%s\tCNAME\t%s\n" % (
                c_ref['name'], c_ref['ttl'] or '',
                exp_name(c_ref['target_name']))
            # for machines with multiple a-records and cnames, the
            # cnames will be listed before the last a-records.
            prev_name = ''
        f.write(line)
    f.write('; End of a-record owned entries\n')
    for row in DnsOwner.DnsOwner(db).list():
        line = ''
        # Check for any remaining data.  Should only be srv_records
        # and cnames with foreign targets
        name = row['name']
        for s_ref in srv_records.get(row['dns_owner_id'], []):
            line += "%s\t%i\tSRV\t%i\t%i\t%i\t%s\n" % (name,
                s_ref['ttl'], s_ref['pri'], s_ref['weight'],
                s_ref['port'], exp_name(s_ref['target_name']))
            name = ''
        if not shown_owner.has_key(row['dns_owner_id']):
            if owner_id2mx_set[int(row['dns_owner_id'])]:
                for mx_info in mx_sets[owner_id2mx_set[int(row['dns_owner_id'])]]:
                    line += "%s\t%s\tMX\t%s\t%s\n" % (
                        name, mx_info['ttl'] or '', mx_info['pri'],
                        exp_name(mx_info['target_name']))
                    name = ''
            for c_ref in cnames.get(row['dns_owner_id'], []):
                line += "%s\t%s\tCNAME\t%s\n" % (
                    c_ref['name'], c_ref['ttl'] or '',
                    exp_name(c_ref['target_name']))
        if line:
            f.write(line)
    f.close()
    if f.replaced_file:
        write_file_with_serial(fname+".status", fname, heads)

def generate_hosts_file(fname):
    f = Utils.SimilarSizeWriter(fname, "w")
    f.set_size_change_limit(10)
    (a_records, hosts, cnames, mx_sets, owner_id2mx_set,
     dnsowner2txt_record, srv_records) = get_zone_data()
    order = a_records.keys()
    order.sort(lambda x,y: int(a_records[x]['ipnr'] - a_records[y]['ipnr']))

    # If multiple A-records have the same name with different IP, the
    # dns_owner data is only shown for the first IP.
    shown_owner = {}
    prev_name = None
    for a_id in order:
        line = ''
        a_ref = a_records[a_id]

        line = '%s\t%s %s' % (a_ref['a_ip'], a_ref['name'],
                                exp_name(a_ref['name'], no_dot=True))

        names = [ ]

        dns_owner_id = int(a_ref['dns_owner_id'])
        if shown_owner.has_key(dns_owner_id):
            # raise ValueError, "%s already shown?" % a_ref['name']
            continue
        shown_owner[dns_owner_id] = True

        for c_ref in cnames.get(dns_owner_id, []):
            names.append(c_ref['name'])

        # TODO:  Should lines be wrapped?
        line += " ".join(
            ["%s %s" % (n, exp_name(n, no_dot=True)) for n in names])
        f.write(line+"\n")
    f.close()

def get_reverse_data():
    ip_numbers = {}
    for row in IPNumber.IPNumber(db).list():
        ip_numbers[int(row['ip_number_id'])] = row
        
    a_records = {}
    for row in ARecord.ARecord(db).list_ext():
        a_records[int(row['ip_number_id'])] = row

    #override_name = {}
    override_ip = {}
    for row in IPNumber.IPNumber(db).list_override():
        #override_name[row['a_record_name']] = row
        override_ip[row['ip_number_id']] = row
    return (ip_numbers, a_records, override_ip)

def generate_reverse_file(fname, heads):
    f = Utils.SimilarSizeWriter(fname+".status", "w")
    f.set_size_change_limit(10)

    (ip_numbers, a_records, override_ip) = get_reverse_data()
    order = ip_numbers.keys()
    order.sort(lambda x,y: int(ip_numbers[x]['ipnr'] - ip_numbers[y]['ipnr']))
    this_net = 'z'
    for ip_id in order:
        hostname = None
        if override_ip.has_key(ip_id):
            if override_ip[ip_id]['name'] is None:
                logger.debug("explicitly no reverse for %i" % ip_id)
                continue
            if not a_records.has_key(ip_id):
                logger.debug("reverse-map override with no a-record %i" % ip_id)
            hostname = str(override_ip[ip_id]['name'])
        elif a_records.has_key(ip_id):
            hostname = a_records[ip_id]['name']
        else:
            logger.warn("dangling ip-number %i" % ip_id)
            continue
        if hostname is None:
            logger.error("Hostname not set for %i" % ip_id)
            continue
        a_ip = ip_numbers[ip_id]['a_ip']
        if not a_ip.startswith(this_net):
            this_net = a_ip[:a_ip.rfind(".")+1]
            tmp = a_ip.split('.')
            tmp.reverse()
            line = '$ORIGIN %s.%s.%s.IN-ADDR.ARPA.\n' % tuple(tmp[1:4])
            f.write(line)
        a_ip = a_ip[a_ip.rfind(".")+1:]
        line = "%s\tPTR\t%s\n" % (a_ip, exp_name(hostname))
        f.write(line)
    # TODO: add rest of overrides
    f.close()
    if f.replaced_file:
        write_file_with_serial(fname+".status", fname, heads)

def write_file_with_serial(dta_file, fname, heads):
  # Avoid updating serial if file was not changed
  f = Utils.SimilarSizeWriter(fname, "w")
  f.set_size_change_limit(10)
  f.write(header_splitter)
  serial_file, serial = write_heads(f, heads)
  fin = file(dta_file)
  for line in fin:
      f.write(line)
  fin.close()
  f.close()
  write_serial(serial_file, serial)

def new_serial(fname):
    """Returns a serial > than the one in fname"""
    serial = None
    if os.path.isfile(fname):
        fin = file(fname)
        serial = fin.readline()
        if serial[:-2] == time.strftime('%Y%m%d'):
            serial = int(serial) + 1
        else:
            serial = None
        fin.close()
    if serial is None:
        serial = time.strftime('%Y%m%d') + '01'
    return serial

def write_serial(fname, serial):
    """Stores serial in file"""
    fout = file(fname, "w")
    fout.write("%s" % serial)
    fout.close()

def write_heads(f, heads):
    # Write headers, optionally writing serialnumber
    re_serial = re.compile(r'(\d+)\s*;\s*Serialnumber')
    serial_file = "%s.serial" % heads[0]
    serial = new_serial(serial_file)
    for h in heads:
        fin = file(h, "r")
        for line in fin:
            m = re_serial.search(line)
            if m:
                line = "%30s ; Serialnumber\n" % serial
            f.write(line)
        fin.close()
    return serial_file, serial

def usage(exitcode=0):
    print """Usage: [options]
    Builds new zone file.

    -h | --help: help
    -b | --build filename: write new zonefile to filename
    -r | --reverse filename: write new reverse map to filename
    --head filename: header for the static part of the zone-file.  May
      be repeated.  One line must end with '\d+ ; Serialnumber'
      required for -b/-r
    --hosts filename: write new hosts file to filename
    """
    sys.exit(exitcode)

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'b:hr:', [
            'help', 'build=', 'reverse=', 'hosts=', 'head='])
    except getopt.GetoptError:
        usage(1)

    heads = []
    for opt, val in opts:
        if opt in ('--help', '-h'):
            usage()
        elif opt in ('--head',):
            heads.append(val)
        elif opt in ('--build', '-b'):
            if not heads:
                usage(1)
            generate_zone_file(val, heads)
        elif opt in ('--reverse', '-r'):
            if not heads:
                usage(1)
            generate_reverse_file(val, heads)
        elif opt in ('--hosts', ):
            generate_hosts_file(val)

if __name__ == '__main__':
    main()

# arch-tag: d18c6bc2-8ab3-44c0-b499-436bcfc95394
