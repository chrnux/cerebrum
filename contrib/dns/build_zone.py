#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

import os
import re
import sys
import time
import getopt
import cereconf

from Cerebrum import Utils
from Cerebrum.Utils import Factory
from Cerebrum.modules.dns import ARecord
from Cerebrum.modules.dns import HostInfo
from Cerebrum.modules.dns import DnsOwner
from Cerebrum.modules.dns import IPNumber
from Cerebrum.modules.dns import CNameRecord
from Cerebrum.modules.dns.Utils import IPCalc

db = Factory.get('Database')()
co = Factory.get('Constants')(db)
#sys.argv.extend(["--logger-level", "DEBUG"])
logger = Factory.get_logger("cronjob")

header_splitter = '; WARNING: This file is autogenerated by buildzone.py\n'
# extra_splitter is used by strip4cmp.py
extra_splitter = '; AUTOGENERATED: do not edit below this line\n'

class ZoneUtils(object):
    def __init__(self, zone, origin=None):
        self._zone = zone
        self._as_reversemap = False
        if zone is None:
            self._as_reversemap = True
            self.__origin = origin
        
    def exp_name(self, name, no_dot=False):
        ret = name
        if not name[-1] == '.':
            ret = name+self._zone.postfix
        if no_dot and ret[-1] == '.':
            ret = ret[:-1]
        return ret

    def trim_name(self, name):
        if name.endswith(self._zone.postfix):
            return name[:-len(self._zone.postfix)]
        return name

    def write_file_with_serial(self, dta_file, fname, heads):
      # Avoid updating serial if file was not changed
      f = Utils.SimilarSizeWriter(fname, "w")
      f.set_size_change_limit(10)
      f.write(header_splitter)
      serial_file, serial = self.__write_heads(fname, f, heads)
      f.write(extra_splitter)
      fin = file(dta_file)
      for line in fin:
          f.write(line)
      fin.close()
      f.close()
      self.__write_serial(serial_file, serial)

    def __new_serial(self, fname):
        """Returns a serial > than the one in fname"""
        serial = None
        if os.path.isfile(fname):
            fin = file(fname)
            serial = fin.readline()
            if serial[:-2] == time.strftime('%Y%m%d'):
                serial = int(serial) + 1
            else:
                serial = None
            fin.close()
        if serial is None:
            serial = time.strftime('%Y%m%d') + '01'
        return serial

    def __write_serial(self, fname, serial):
        """Stores serial in file"""
        fout = file(fname, "w")
        fout.write("%s" % serial)
        fout.close()

    def __write_heads(self, fname, f, heads):
        # Write headers, optionally writing serialnumber
        re_serial = re.compile(r'(\d+)\s*;\s*Serialnumber')
        serial_file = "%s.serial" % fname
        serial = self.__new_serial(serial_file)
        first = True
        for h in heads:
            fin = file(h, "r")
            lines = []
            for line in fin:
                m = re_serial.search(line)
                if m:
                    line = "%30s ; Serialnumber\n" % serial
                lines.append(line)
            if first and self._as_reversemap and not [
                x for x in lines if x.startswith('$ORIGIN')]:
                lines.insert(0, self.__origin)
            f.write("".join(lines))
            fin.close()
            first = False
        return serial_file, serial

class ForwardMap(object):
    # Currently we first read all required data into memory before writing
    # the new zone file.  It is assumed that it will be faster, since
    # fewver sql queries will be needed.

    def __init__(self, zone):
        self.zu = ZoneUtils(zone)
        self.a_records = {}
        self.hosts = {}
        self.cnames = {}
        self.mx_sets = {}
        self.owner_id2mx_set = {}
        self.dnsowner2txt_record = {}
        self.srv_records = {}
        self._get_zone_data()
        
    def _get_zone_data(self):
        # ARecord has key=a_record_id
        # HostInfo, SrvRecord has key=dns_owner_id
        # CnameRecords key=target_owner_id
        # entity2txt, entity2note has_key=entity_id
        for row in ARecord.ARecord(db).list_ext():
            self.a_records[int(row['a_record_id'])] = row

        for row in HostInfo.HostInfo(db).list():
            # Unique constraint on dns_owner_id
            self.hosts[int(row['dns_owner_id'])] = row

        for row in CNameRecord.CNameRecord(db).list_ext():
            # TBD:  skal vi ha unique constraint på dns_owner?
            self.cnames.setdefault(int(row['target_owner_id']), []).append(row)

        # From mix-in classes
        for row in DnsOwner.MXSet(db).list_mx_sets():
            self.mx_sets.setdefault(int(row['mx_set_id']), []
                                    ).append(row)

        for row in DnsOwner.DnsOwner(db).list():
            self.owner_id2mx_set[int(row['dns_owner_id'])] = int(
                row['mx_set_id'] or 0)

        for row in DnsOwner.DnsOwner(db).list_general_dns_records(
            field_type=co.field_type_txt):
            self.dnsowner2txt_record[int(row['dns_owner_id'])] = row

        for row in DnsOwner.DnsOwner(db).list_srv_records():
            # We want them listed in the same place
            # TODO: while doing that, we want it below the first target_owner_id
            self.srv_records.setdefault(
                int(row['service_owner_id']), []).append(row) 

    def generate_zone_file(self, fname, heads):
        f = Utils.SimilarSizeWriter(fname+".status", "w")
        f.set_size_change_limit(10)

        order = self.a_records.keys()
        order.sort(lambda x,y: int(self.a_records[x]['ipnr'] - self.a_records[y]['ipnr']))

        # If multiple A-records have the same name with different IP, the
        # dns_owner data is only shown for the first IP.
        shown_owner = {}
        prev_name = None
        for a_id in order:
            logger.debug2("A: %s" % a_id)
            line = ''
            a_ref = self.a_records[a_id]
            name = self.zu.trim_name(a_ref['name'])
            if name == prev_name:
                tmp_name = ''
            else:
                tmp_name = name
                prev_name = name
            line = "%s\t%s\tA\t%s\n" % (
                tmp_name, a_ref['ttl'] or '', a_ref['a_ip'])

            dns_owner_id = int(a_ref['dns_owner_id'])
            if shown_owner.has_key(dns_owner_id):
                f.write(line)
                continue
            shown_owner[dns_owner_id] = True
            logger.debug2("A: %s, owner=%s" % (a_id, dns_owner_id))
            if self.hosts.has_key(dns_owner_id):
                line += "\t%s\tHINFO\t%s\n" % (
                    self.hosts[dns_owner_id]['ttl'] or '',
                    self.hosts[dns_owner_id]['hinfo'])
            #logger.debug("own=%i %s" % (dns_owner_id, str(owner_id2mx_set[dns_owner_id])))
            if self.owner_id2mx_set[dns_owner_id]:
                for mx_info in self.mx_sets[self.owner_id2mx_set[dns_owner_id]]:
                    line += "\t%s\tMX\t%s\t%s\n" % (
                        mx_info['ttl'] or '', mx_info['pri'],
                        self.zu.exp_name(mx_info['target_name']))
            txt = self.dnsowner2txt_record.get(dns_owner_id, None)
            if txt:
                line += "\t%s\tTXT\t\"%s\"\n" % (txt['ttl'] or '', txt['data'])

            for c_ref in self.cnames.get(dns_owner_id, []):
                line += "%s\t%s\tCNAME\t%s\n" % (
                    c_ref['name'], c_ref['ttl'] or '',
                    self.zu.exp_name(c_ref['target_name']))
                # for machines with multiple a-records and cnames, the
                # cnames will be listed before the last a-records.
                prev_name = ''
            f.write(line)
        f.write('; End of a-record owned entries\n')
        for row in DnsOwner.DnsOwner(db).list():
            line = ''
            # Check for any remaining data.  Should only be srv_records
            # and cnames with foreign targets
            name = self.zu.trim_name(row['name'])
            for s_ref in self.srv_records.get(row['dns_owner_id'], []):
                line += "%s\t%s\tSRV\t%i\t%i\t%i\t%s\n" % (name,
                    s_ref['ttl'] or '', s_ref['pri'], s_ref['weight'],
                    s_ref['port'], self.zu.exp_name(s_ref['target_name']))
                name = ''
            if not shown_owner.has_key(row['dns_owner_id']):
                if self.owner_id2mx_set[int(row['dns_owner_id'])]:
                    for mx_info in self.mx_sets[self.owner_id2mx_set[int(row['dns_owner_id'])]]:
                        line += "%s\t%s\tMX\t%s\t%s\n" % (
                            name, mx_info['ttl'] or '', mx_info['pri'],
                            self.zu.exp_name(mx_info['target_name']))
                        name = ''
                for c_ref in self.cnames.get(row['dns_owner_id'], []):
                    line += "%s\t%s\tCNAME\t%s\n" % (
                        c_ref['name'], c_ref['ttl'] or '',
                        self.zu.exp_name(c_ref['target_name']))
            if line:
                f.write(line)
        f.close()
        if f.replaced_file:
            self.zu.write_file_with_serial(fname+".status", fname, heads)

class ReverseMap(object):
    def __init__(self, mask):
        self.ip_numbers = {}
        self.a_records = {}
        self.override_ip = {}
        ipu = IPCalc()
        net, mask = mask.split("/")
        self._get_reverse_data(*ipu.ip_range_by_netmask(net, int(mask)))
        tmp = net.split(".")
        if int(mask) < 24:
            net = ".".join(tmp[:2])
        else:
            net = ".".join(tmp[:3])
        self.__prev_origin = self.__net2origin(net)
        self.zu = ZoneUtils(None, self.__prev_origin)
    
    def _get_reverse_data(self, start, stop):
        for row in IPNumber.IPNumber(db).list(start=start, stop=stop):
            self.ip_numbers[int(row['ip_number_id'])] = row

        for row in ARecord.ARecord(db).list_ext(start=start, stop=stop):
            self.a_records.setdefault(int(row['ip_number_id']), []).append(row)

        for row in IPNumber.IPNumber(db).list_override(start=start, stop=stop):
            self.override_ip.setdefault(int(row['ip_number_id']), []).append(row)
        logger.debug("_get_reverse_data -> %i, %i, %i" % (
            len(self.ip_numbers), len(self.a_records), len(self.override_ip)))

    def __net2origin(self, ip):
        tmp = ip.split('.')[:3]
        tmp.reverse()
        return '$ORIGIN %s.IN-ADDR.ARPA.\n' % ".".join(tmp)

    def generate_reverse_file(self, fname, heads):
        f = Utils.SimilarSizeWriter(fname+".status", "w")
        f.set_size_change_limit(10)

        order = self.ip_numbers.keys()
        order.sort(lambda x,y: int(self.ip_numbers[x]['ipnr'] - self.ip_numbers[y]['ipnr']))
        this_net = 'z'
        for ip_id in order:
            if self.override_ip.has_key(ip_id):
                tmp = self.override_ip[ip_id]
            elif self.a_records.has_key(ip_id):
                tmp = self.a_records[ip_id]
            else:
                logger.warn("dangling ip-number %i" % ip_id)
                continue
            a_ip = self.ip_numbers[ip_id]['a_ip']
            if not a_ip.startswith(this_net):
                this_net = a_ip[:a_ip.rfind(".")+1]
                line = self.__net2origin(a_ip)
                if line != self.__prev_origin:
                    f.write(line)
                    self.__prev_origin = line  # avoid dupl. $ORIGIN in /24 net
            a_ip = a_ip[a_ip.rfind(".")+1:]
            for row in tmp:
                if row['name'] is not None:
                    line = "%s\tPTR\t%s\n" % (a_ip, row['name'])
                    f.write(line)
        f.close()
        if f.replaced_file:
            self.zu.write_file_with_serial(fname+".status", fname, heads)

class HostsFile(object):
    def __init__(self, zone):
        self._zone = zone
        self.zu = ZoneUtils(zone)

    def _exp_name(self, name):
        """Returns name name.uio.no or only FQDN if name is from
        another zone"""
        trimmed = self.zu.trim_name(name)
        if name != trimmed:
            return "%s %s" % (trimmed, name[:-1])
        return name[:-1]
    
    def generate_hosts_file(self, fname):
        f = Utils.SimilarSizeWriter(fname, "w")
        f.set_size_change_limit(10)
        fm = ForwardMap(self._zone)
        order = fm.a_records.keys()
        order.sort(lambda x,y: int(fm.a_records[x]['ipnr'] - fm.a_records[y]['ipnr']))

        # If multiple A-records have the same name with different IP, the
        # dns_owner data is only shown for the first IP.
        shown_owner = {}
        prev_name = None
        for a_id in order:
            line = ''
            a_ref = fm.a_records[a_id]

            line = '%s\t%s' % (a_ref['a_ip'], self._exp_name(a_ref['name']))
            names = [ ]

            dns_owner_id = int(a_ref['dns_owner_id'])
            if shown_owner.has_key(dns_owner_id):
                # raise ValueError, "%s already shown?" % a_ref['name']
                continue
            shown_owner[dns_owner_id] = True

            for c_ref in fm.cnames.get(dns_owner_id, []):
                names.append(c_ref['name'])

            # TODO:  Should lines be wrapped?
            line += " " + " ".join([self._exp_name(n) for n in names])
            f.write(line+"\n")
        f.close()

def usage(exitcode=0):
    print """Usage: [options]
    Builds new zone file.

    -h | --help: help
    -Z | --zone zone: use with -b to specify zone
    -m | --mask net/mask: use with -r to specify iprange
    -b | --build filename: write new zonefile to filename
    -r | --reverse filename: write new reverse map to filename
    --head filename: header for the static part of the zone-file.  May
      be repeated.  One line must end with '\d+ ; Serialnumber'
      required for -b/-r
    --hosts filename: write new hosts file to filename
    """
    sys.exit(exitcode)

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'b:hr:Z:m:', [
            'help', 'build=', 'reverse=', 'hosts=', 'head=', 'zone=', 'mask='])
    except getopt.GetoptError:
        usage(1)

    heads = []
    for opt, val in opts:
        if opt in ('--help', '-h'):
            usage()
        elif opt in ('--head',):
            heads.append(val)
        elif opt in ('--zone', '-Z'):
            zone = co.DnsZone(val)
            int(zone) # Triggers error if missing
        elif opt in ('--mask', '-m'):
            mask = val
        elif opt in ('--build', '-b'):
            if not heads:
                usage(1)
            fm = ForwardMap(zone)
            fm.generate_zone_file(val, heads)
        elif opt in ('--reverse', '-r'):
            if not (heads and mask):
                usage(1)
            rm = ReverseMap(mask)
            rm.generate_reverse_file(val, heads)
        elif opt in ('--hosts', ):
            hf = HostsFile(zone)
            hf.generate_hosts_file(val)

if __name__ == '__main__':
    main()

# arch-tag: d18c6bc2-8ab3-44c0-b499-436bcfc95394
