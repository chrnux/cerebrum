#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

import os
import re
import sys
import time
import getopt

import cerebrum_path
import cereconf

from Cerebrum import Utils
from Cerebrum.Utils import Factory
from Cerebrum.modules.dns import ARecord
from Cerebrum.modules.dns import HostInfo
from Cerebrum.modules.dns import DnsOwner
from Cerebrum.modules.dns import IPNumber
from Cerebrum.modules.dns import CNameRecord
from Cerebrum.modules.dns.Utils import IPCalc

db = Factory.get('Database')()
co = Factory.get('Constants')(db)
#sys.argv.extend(["--logger-level", "DEBUG"])
logger = Factory.get_logger("cronjob")

header_splitter = '; WARNING: This file is autogenerated by buildzone.py\n'
# extra_splitter is used by strip4cmp.py
extra_splitter = '; AUTOGENERATED: do not edit below this line\n'

class FileChangeTooBigError(Exception):
    def __init__(self, msg, tmpfile):
        self.msg = msg
        self.tmpfile = tmpfile
        
class ExtSimilarSizeWriter(Utils.AtomicFileWriter):
    def _count_lines(self, fname):
        count = 0
        for line in open(fname):
            count = count + 1
        return count

    def validate_output(self):
        super(ExtSimilarSizeWriter, self).validate_output()
        if not os.path.exists(self._name):
            return
        old = os.path.getsize(self._name)
        if old == 0:
            return
        new = os.path.getsize(self._tmpname)
        # TODO: should be possible to adjust these levels, and perhaps
        # ignore lines in headers
        old = self._count_lines(self._name)
        new = self._count_lines(self._tmpname)
        if old < 100 and new < 100:
            delta = 50
        elif old > 10000 and new > 10000:
            delta = 500
        else:
            delta = 150
        if abs(old - new) > delta:
            raise FileChangeTooBigError(
                  "%s: File changed more than %d lines: %d -> %d (%i)" % (
                self._name, delta, old, new, abs(old-new)), self._tmpname)

    def rename_tmpfile(self):
        os.rename(self._tmpname, self._name)


class ZoneUtils(object):
    re_serial = re.compile(r'(\d+)\s*;\s*Serialnumber')

    def __init__(self, zone, origin=None, lc_delta=100):
        self._zone = zone
        self._as_reversemap = False
        self.__lc_delta = lc_delta
        if zone is None:
            self._as_reversemap = True
            self.__origin = origin
        
    def exp_name(self, name, no_dot=False):
        ret = name
        if not name[-1] == '.':
            ret = name+self._zone.postfix
        if no_dot and ret[-1] == '.':
            ret = ret[:-1]
        return ret

    def trim_name(self, name):
        if name.endswith(self._zone.postfix):
            return name[:-len(self._zone.postfix)]
        return name

    def open(self, fname):
        self._file = ExtSimilarSizeWriter(fname, "w")
        self._fname = fname

    def write_heads(self, heads, data_dir):
        """Writes the zone-file header file(s), re-using the old
        serial number"""

        self._file.write(header_splitter)
        serial = self._read_update_serial(self._fname)
        first = True
        for h in heads:
            fin = file(h, "r")
            lines = []
            for line in fin:
                m = ZoneUtils.re_serial.search(line)
                if m:
                    line = "%30s ; Serialnumber\n" % serial
                lines.append(line)
            if first and self._as_reversemap and not [
                x for x in lines if x.startswith('$ORIGIN')]:
                lines.insert(0, self.__origin)
            self._file.write("".join(lines))
            fin.close()
            first = False
        self._file.write(extra_splitter)

    def close(self):
        try:
            self._file.close(dont_rename=True)
        except FileChangeTooBigError:
            # Want the tmp-file to have new serial so that we can
            # manually rename if the change is OK.
            self._read_update_serial(self._file._tmpname, update=True)
            raise
        if self._file.replaced_file:
            self._read_update_serial(self._file._tmpname, update=True)
            self._file.rename_tmpfile()

    def write(self, s):
        self._file.write(s)

    def _read_update_serial(self, fname, update=False):
        """Parse existing serial in zonefile, and opionally updates
        the serial.  Returns the serial used.  """

        all_lines = []
        if os.path.exists(fname):
            for line in open(fname):
                m = ZoneUtils.re_serial.search(line)
                if m:
                    serial = m.group(1)
                    if not update:
                        return serial
                    if serial[:-2] == time.strftime('%Y%m%d'):
                        serial = int(serial) + 1
                    else:
                        serial = time.strftime('%Y%m%d') + '01'
                    line = "%30s ; Serialnumber\n" % serial
                all_lines.append(line)
        if not update:
            # First time this zone is written
            return time.strftime('%Y%m%d') + '01'
        # Rewrite the entire file in case the serial line length has changed
        f = Utils.AtomicFileWriter(fname, 'w')
        f.write("".join(all_lines))
        f.close()

class ForwardMap(object):
    # Currently we first read all required data into memory before writing
    # the new zone file.  It is assumed that it will be faster, since
    # fewver sql queries will be needed.

    def __init__(self, zone, lc_delta):
        self.zu = ZoneUtils(zone, lc_delta=lc_delta)
        self.a_records = {}
        self.hosts = {}
        self.cnames = {}
        self.mx_sets = {}
        self.owner_id2mx_set = {}
        self.dnsowner2txt_record = {}
        self.srv_records = {}
        logger.debug("Getting zone data")
        self._get_zone_data(zone)
        logger.debug("done getting zone data")
        self.__lc_delta = lc_delta
      
    def _get_zone_data(self, zone):
        # ARecord has key=a_record_id
        # HostInfo, SrvRecord has key=dns_owner_id
        # CnameRecords key=target_owner_id
        # entity2txt, entity2note has_key=entity_id
        for row in ARecord.ARecord(db).list_ext(zone=zone):
            self.a_records[int(row['a_record_id'])] = row
        logger.debug("... arecords")

        for row in HostInfo.HostInfo(db).list(zone=zone):
            # Unique constraint on dns_owner_id
            self.hosts[int(row['dns_owner_id'])] = row

        logger.debug("... hosts")
        for row in CNameRecord.CNameRecord(db).list_ext(zone=zone):
            # TBD:  skal vi ha unique constraint på dns_owner?
            self.cnames.setdefault(int(row['target_owner_id']), []).append(row)
        logger.debug("... cnames")

        # From mix-in classes
        for row in DnsOwner.MXSet(db).list_mx_sets():
            self.mx_sets.setdefault(int(row['mx_set_id']), []
                                    ).append(row)

        logger.debug("... mx_sets")
        for row in DnsOwner.DnsOwner(db).list(zone=zone):
            self.owner_id2mx_set[int(row['dns_owner_id'])] = int(
                row['mx_set_id'] or 0)

        logger.debug("... mx_set owners")

        for row in DnsOwner.DnsOwner(db).list_general_dns_records(
            field_type=co.field_type_txt, zone=zone):
            self.dnsowner2txt_record[int(row['dns_owner_id'])] = row
        logger.debug("... txt reocrds")

        for row in DnsOwner.DnsOwner(db).list_srv_records(zone=zone):
            # We want them listed in the same place
            # TODO: while doing that, we want it below the first target_owner_id
            self.srv_records.setdefault(
                int(row['service_owner_id']), []).append(row) 
        logger.debug("... srv records")

    def generate_zone_file(self, fname, heads, data_dir):
        logger.debug("Generating zone file")
        self.zu.open(os.path.join(data_dir, os.path.basename(fname)))
        self.zu.write_heads(heads, data_dir)

        order = self.a_records.keys()
        order.sort(lambda x,y: int(self.a_records[x]['ipnr'] - self.a_records[y]['ipnr']))

        # If multiple A-records have the same name with different IP, the
        # dns_owner data is only shown for the first IP.
        shown_owner = {}
        prev_name = None
        for a_id in order:
            #logger.debug2("A: %s" % a_id)
            line = ''
            a_ref = self.a_records[a_id]
            name = self.zu.trim_name(a_ref['name'])
            if name == prev_name:
                tmp_name = ''
            else:
                tmp_name = name
                prev_name = name
            line = "%s\t%s\tA\t%s\n" % (
                tmp_name, a_ref['ttl'] or '', a_ref['a_ip'])

            dns_owner_id = int(a_ref['dns_owner_id'])
            if shown_owner.has_key(dns_owner_id):
                self.zu.write(line)
                continue
            shown_owner[dns_owner_id] = True
            #logger.debug2("A: %s, owner=%s" % (a_id, dns_owner_id))
            if self.hosts.has_key(dns_owner_id):
                line += "\t%s\tHINFO\t%s\n" % (
                    self.hosts[dns_owner_id]['ttl'] or '',
                    self.hosts[dns_owner_id]['hinfo'])
            #logger.debug("own=%i %s" % (dns_owner_id, str(owner_id2mx_set[dns_owner_id])))
            if self.owner_id2mx_set.get(dns_owner_id, None):
                for mx_info in self.mx_sets[self.owner_id2mx_set[dns_owner_id]]:
                    line += "\t%s\tMX\t%s\t%s\n" % (
                        mx_info['ttl'] or '', mx_info['pri'],
                        self.zu.exp_name(mx_info['target_name']))
            txt = self.dnsowner2txt_record.get(dns_owner_id, None)
            if txt:
                line += "\t%s\tTXT\t\"%s\"\n" % (txt['ttl'] or '', txt['data'])

            for c_ref in self.cnames.get(dns_owner_id, []):
                line += "%s\t%s\tCNAME\t%s\n" % (
                    c_ref['name'], c_ref['ttl'] or '',
                    self.zu.exp_name(c_ref['target_name']))
                # for machines with multiple a-records and cnames, the
                # cnames will be listed before the last a-records.
                prev_name = ''
            self.zu.write(line)
        self.zu.write('; End of a-record owned entries\n')
        logger.debug("Check remaining data")
        for row in DnsOwner.DnsOwner(db).list():
            line = ''
            # Check for any remaining data.  Should only be srv_records
            # and cnames with foreign targets
            name = self.zu.trim_name(row['name'])
            for s_ref in self.srv_records.get(row['dns_owner_id'], []):
                line += "%s\t%s\tSRV\t%i\t%i\t%i\t%s\n" % (name,
                    s_ref['ttl'] or '', s_ref['pri'], s_ref['weight'],
                    s_ref['port'], self.zu.exp_name(s_ref['target_name']))
                name = ''
            if not shown_owner.has_key(row['dns_owner_id']):
                if self.owner_id2mx_set.get(int(row['dns_owner_id']), None):
                    for mx_info in self.mx_sets[self.owner_id2mx_set[int(row['dns_owner_id'])]]:
                        line += "%s\t%s\tMX\t%s\t%s\n" % (
                            name, mx_info['ttl'] or '', mx_info['pri'],
                            self.zu.exp_name(mx_info['target_name']))
                        name = ''
                for c_ref in self.cnames.get(row['dns_owner_id'], []):
                    line += "%s\t%s\tCNAME\t%s\n" % (
                        c_ref['name'], c_ref['ttl'] or '',
                        self.zu.exp_name(c_ref['target_name']))
            if line:
                self.zu.write(line)
        self.zu.close()
        logger.debug("zone file completed")

class ReverseMap(object):
    def __init__(self, mask, lc_delta):
        self.ip_numbers = {}
        self.a_records = {}
        self.override_ip = {}
        ipu = IPCalc()
        net, mask = mask.split("/")
        self._get_reverse_data(*ipu.ip_range_by_netmask(net, int(mask)))
        tmp = net.split(".")
        if int(mask) < 24:
            net = ".".join(tmp[:2])
        else:
            net = ".".join(tmp[:3])
        self.__prev_origin = self.__net2origin(net)
        self.zu = ZoneUtils(None, self.__prev_origin,
                            lc_delta=lc_delta)
        self.__lc_delta = lc_delta
    
    def _get_reverse_data(self, start, stop):
        for row in IPNumber.IPNumber(db).list(start=start, stop=stop):
            self.ip_numbers[int(row['ip_number_id'])] = row

        for row in ARecord.ARecord(db).list_ext(start=start, stop=stop):
            self.a_records.setdefault(int(row['ip_number_id']), []).append(row)

        for row in IPNumber.IPNumber(db).list_override(start=start, stop=stop):
            self.override_ip.setdefault(int(row['ip_number_id']), []).append(row)
        logger.debug("_get_reverse_data -> %i, %i, %i" % (
            len(self.ip_numbers), len(self.a_records), len(self.override_ip)))

    def __net2origin(self, ip):
        tmp = ip.split('.')[:3]
        tmp.reverse()
        return '$ORIGIN %s.IN-ADDR.ARPA.\n' % ".".join(tmp)

    def generate_reverse_file(self, fname, heads, data_dir):
        self.zu.open(os.path.join(data_dir, os.path.basename(fname)))
        self.zu.write_heads(heads, data_dir)

        order = self.ip_numbers.keys()
        order.sort(lambda x,y: int(self.ip_numbers[x]['ipnr'] - self.ip_numbers[y]['ipnr']))
        this_net = 'z'
        for ip_id in order:
            if self.override_ip.has_key(ip_id):
                tmp = self.override_ip[ip_id]
            elif self.a_records.has_key(ip_id):
                tmp = self.a_records[ip_id]
            else:
                logger.warn("dangling ip-number %i" % ip_id)
                continue
            a_ip = self.ip_numbers[ip_id]['a_ip']
            if not a_ip.startswith(this_net):
                this_net = a_ip[:a_ip.rfind(".")+1]
                line = self.__net2origin(a_ip)
                if line != self.__prev_origin:
                    self.zu.write(line)
                    self.__prev_origin = line  # avoid dupl. $ORIGIN in /24 net
            a_ip = a_ip[a_ip.rfind(".")+1:]
            for row in tmp:
                if row['name'] is not None:
                    line = "%s\tPTR\t%s\n" % (a_ip, row['name'])
                    self.zu.write(line)
        self.zu.close()

class HostsFile(object):
    MAX_LINE_LENGTH = 1000
    def __init__(self, zone, lc_delta):
        self._zone = zone
        self.zu = ZoneUtils(zone, lc_delta=lc_delta)
        self.__lc_delta = lc_delta

    def _exp_name(self, name):
        """Returns name name.uio.no or only FQDN if name is from
        another zone"""
        trimmed = self.zu.trim_name(name)
        if name != trimmed:
            return "%s %s" % (trimmed, name[:-1])
        return name[:-1]
    
    def generate_hosts_file(self, fname, with_comments=False):
        f = Utils.SimilarSizeWriter(fname, "w")
        f.set_line_count_change_limit(self.__lc_delta)
        fm = ForwardMap(self._zone, self.__lc_delta)
        order = fm.a_records.keys()
        order.sort(lambda x,y: int(fm.a_records[x]['ipnr'] - fm.a_records[y]['ipnr']))

        entity_id2comment = {}
        if with_comments:
            for row in DnsOwner.DnsOwner(db).list_traits(co.trait_dns_comment):
                entity_id2comment[int(row['entity_id'])] = ' # ' + row['strval']

        # If multiple A-records have the same name with different IP, the
        # dns_owner data is only shown for the first IP.
        shown_owner = {}
        prev_name = None
        for a_id in order:
            line = ''
            a_ref = fm.a_records[a_id]

            prefix = '%s\t%s' % (a_ref['a_ip'], self._exp_name(a_ref['name']))
            line = ''
            names = [ ]

            dns_owner_id = int(a_ref['dns_owner_id'])
            if shown_owner.has_key(dns_owner_id):
                # raise ValueError, "%s already shown?" % a_ref['name']
                continue
            shown_owner[dns_owner_id] = True

            for c_ref in fm.cnames.get(dns_owner_id, []):
                names.append(c_ref['name'])

            line += " " + " ".join([self._exp_name(n) for n in names])
            line += entity_id2comment.get(int(a_ref['dns_owner_id']), '')

            f.write(self._wrap_line(prefix, line))
        f.close()

    def _wrap_line(self, prefix, line):
        delim = ' '
        ret = ''
        maxlen = HostsFile.MAX_LINE_LENGTH - (len(prefix) + 1)
        if len(line) > maxlen:
            idx = line.find(' #')
            if idx != -1:
                line = line[:idx]
        while len(line) > maxlen:
            maxlen = HostsFile.MAX_LINE_LENGTH - (len(prefix) + 1)
            if len(line) <= maxlen:
                pos = 0
            else:
                pos = line.index(delim, len(line) - maxlen)
            ret += "%s%s%s\n" % (prefix, ' ', line[pos+1:])
            line = line[:pos]
        return ret + "%s%s%s\n" % (prefix, ' ', line)


def usage(exitcode=0):
    print """Usage: [options]
    Builds new zone file.

    -h | --help: help
    -Z | --zone zone: use with -b to specify zone
    -m | --mask net/mask: use with -r to specify iprange
    -b | --build filename: write new zonefile to filename
    -r | --reverse filename: write new reverse map to filename
    -d | --dir dir: store .status/.serial files in this dir (default:
      same dir as filename)
    -C num : line-count delta before we trigger an error
    --head filename: header for the static part of the zone-file.  May
      be repeated.  One line must end with '\d+ ; Serialnumber'
      required for -b/-r
    --hosts filename: write new hosts file to filename
    -R : resets head list
    """
    sys.exit(exitcode)

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'b:hr:Z:m:Rd:C:', [
            'help', 'build=', 'reverse=', 'hosts=', 'head=', 'zone=', 'mask=',
            'dir=', 'comments'])
    except getopt.GetoptError:
        usage(1)

    heads = []
    data_dir = None
    lc_delta = 100
    with_comments = False
    for opt, val in opts:
        if opt in ('--help', '-h'):
            usage()
        elif opt in ('--head',):
            heads.append(val)
        elif opt in ('--zone', '-Z'):
            zone = co.DnsZone(val)
            int(zone) # Triggers error if missing
        elif opt in ('--mask', '-m'):
            mask = val
        elif opt in ('--dir', '-d'):
            data_dir = val
        elif opt in ('-C',):
            lc_delta = int(val)
        elif opt in ('--comments',):
            with_comments = True
        elif opt in ('--build', '-b'):
            if not heads:
                usage(1)
            fm = ForwardMap(zone, lc_delta)
            if data_dir:
                fm.generate_zone_file(val, heads, data_dir)
            else:
                fm.generate_zone_file(val, heads, os.path.dirname(val))
        elif opt in ('--reverse', '-r'):
            if not (heads and mask):
                usage(1)
            rm = ReverseMap(mask, lc_delta)
            if data_dir:
                rm.generate_reverse_file(val, heads, data_dir)
            else:
                rm.generate_reverse_file(val, heads, os.path.dirname(val))
        elif opt in ('--hosts', ):
            hf = HostsFile(zone, lc_delta)
            hf.generate_hosts_file(val, with_comments=with_comments)
        elif opt in ('-R'):
            heads = []

if __name__ == '__main__':
    try:
        main()
    except FileChangeTooBigError, fce:
        print >> sys.stderr, (
            "%s: %s\nCheck %s and rename if the changes seems ok." % (
            fce.__class__.__name__, fce.msg, fce.tmpfile))
        sys.exit(1)

# arch-tag: d18c6bc2-8ab3-44c0-b499-436bcfc95394
