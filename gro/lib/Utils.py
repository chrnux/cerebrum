class Lazy(object):
    pass

# å bruke en klasse med __call__ vil ikke funke, da den ikke vil bli bundet til objektet.
# mulig det kan jukses til med noen stygge metaklassetriks, men dette blir penere.

def LazyMethod(var, load):
    assert type(var) == str
    assert type(load) == str

    def lazy(self):
        value = getattr(self, var)
        if value is Lazy:
            loadmethod = getattr(self, load)
            loadmethod()
            value = getattr(self, var)
            if value is Lazy:
                raise Exception('%s was not initialized during load' % var)
        return value
    return lazy

class Clever(object):
    def __init__(self, cls, *args, **vargs):
        var = '_%s%s' % (cls.__name__, id(self))
        if hasattr(self, var):
            return getattr(self, var)
        setattr(self, var, time.time())
        for var, value in zip(cls.slots, args) + vargs.items():
            setattr(self, '_' + var, value)
        for var in cls.slots:
            var = '_' + var
            hasattr(self, var) or setattr(self, var, Lazy)

    def prepare(cls, defaultLoad=None):
        for i in cls.slots:
            var = '_' + i
            tmp = i[0].upper() + i[1:]
            method = 'get' + tmp

            fget = getattr(cls, method, None)
            fset = getattr(cls, 'set' + tmp, None)
            fdel = getattr(cls, 'del' + tmp, None)

            if not fget:
                if not defaultLoad:
                    raise Exception('check your code, defaultload wasnt given')
                fget = LazyMethod(var, defaultLoad)
                setattr(cls, method, fget)
            if not hasattr(cls, i):
                setattr(cls, i, property(fget, fset, fdel, 'autogenerated for ' + i))

    prepare = staticmethod(prepare)
