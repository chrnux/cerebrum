import weakref
import time

class Cached(object):
    cache = weakref.WeakValueDictionary()

    def __new__(cls, *args, **vargs):
        key = cls, cls.getKey(*args, **vargs)
        
        if key in cls.cache:
            return cls.cache[key]
        
        self = object.__new__(cls)
        cls.cache[key] = self
        return self

class Lazy(object):
    pass

#class LazyMethod(object):
#    def __init__(self, var, load):
#        if type(var) is not str:
#            raise ValueError('var must be a str')
#        self.var = var
#        self.load = load
#
#    def __call__(self, obj):
#        value = getattr(obj, self.var)
#        if value is Lazy:
#            load = getattr(obj, self.load)
#            load()
#            value = getattr(obj, self.var)
#            if value is Lazy:
#                raise Exception('%s was not initialized during load' % self.var)
#        return value

# å bruke en klasse med __call__ vil ikke funke, da den ikke vil bli bundet til objektet.
# mulig det kan jukses til med noen stygge metaklassetriks, men dette blir penere.

def LazyMethod(var, load):
    assert type(var) == str
    assert type(load) == str

    def lazy(self):
        value = getattr(self, var)
        if value is Lazy:
            loadmethod = getattr(self, load)
            loadmethod()
            value = getattr(self, var)
            if value is Lazy:
                raise Exception('%s was not initialized during load' % var)
        return value
    return lazy

class Clever(object):
    def __init__(self, cls, *args, **vargs):
        var = '_%s%s' % (cls.__name__, id(self))
        if hasattr(self, var):
            return getattr(self, var)
        setattr(self, var, time.time())
        for var, value in zip(cls.slots, args) + vargs.items():
            setattr(self, '_' + var, value)
        for var in cls.slots:
            var = '_' + var
            hasattr(self, var) or setattr(self, var, Lazy)

    def prepare(cls, defaultLoad=None):
        for i in cls.slots:
            var = '_' + i
            tmp = i[0].upper() + i[1:]
            method = 'get' + tmp

            fget = getattr(cls, method, None)
            fset = getattr(cls, 'set' + tmp, None)
            fdel = getattr(cls, 'del' + tmp, None)

            if not fget:
                if not defaultLoad:
                    raise Exception('check your code, defaultload wasnt given')
                fget = LazyMethod(var, defaultLoad)
                setattr(cls, method, fget)
            if not hasattr(cls, i):
                setattr(cls, i, property(fget, fset, fdel, 'autogenerated for ' + i))

    prepare = staticmethod(prepare)
